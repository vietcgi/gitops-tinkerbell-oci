# Terraform CI/CD Pipeline
#
# Flow:
#   - PR: terraform plan (posted as comment)
#   - Merge to main: terraform apply
#   - Manual: workflow_dispatch for testing
#   - Schedule: retry apply every 5 mins (for capacity issues)
#

name: Terraform

on:
  # schedule:
  #   - cron: '*/5 * * * *'  # Disabled - ARM instance created
  pull_request:
    branches: [main]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform.yaml'
  push:
    branches: [main]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform.yaml'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
      ad_index:
        description: 'Availability domain index (try 0, 1, or 2 if capacity unavailable)'
        required: false
        default: '0'
        type: choice
        options:
          - '0'
          - '1'
          - '2'

permissions:
  contents: read
  pull-requests: write

# Prevent concurrent runs - only one terraform operation at a time
concurrency:
  group: terraform-${{ github.ref }}
  cancel-in-progress: false

env:
  TF_VERSION: '1.5.7'
  TF_WORKING_DIR: 'terraform'
  # S3 backend credentials (OCI Object Storage)
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  # S3 backend config (bucket stays in original region)
  TF_STATE_BUCKET: 'metal-foundry-state'
  TF_STATE_REGION: ${{ secrets.OCI_STATE_REGION }}
  TF_STATE_ENDPOINT: 'https://${{ secrets.OCI_NAMESPACE }}.compat.objectstorage.${{ secrets.OCI_STATE_REGION }}.oraclecloud.com'
  # Terraform provider variables (lowercase env var, uppercase secret)
  TF_VAR_tenancy_ocid: ${{ secrets.TF_VAR_TENANCY_OCID }}
  TF_VAR_user_ocid: ${{ secrets.TF_VAR_USER_OCID }}
  TF_VAR_fingerprint: ${{ secrets.TF_VAR_FINGERPRINT }}
  TF_VAR_private_key: ${{ secrets.TF_VAR_PRIVATE_KEY }}
  TF_VAR_region: ${{ secrets.TF_VAR_REGION }}
  TF_VAR_compartment_ocid: ${{ secrets.TF_VAR_COMPARTMENT_OCID }}
  TF_VAR_ssh_public_key: ${{ secrets.TF_VAR_SSH_PUBLIC_KEY }}
  TF_VAR_availability_domain_index: ${{ github.event.inputs.ad_index || '0' }}

jobs:
  plan:
    name: Plan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=$TF_STATE_BUCKET" \
            -backend-config="region=$TF_STATE_REGION" \
            -backend-config="endpoint=$TF_STATE_ENDPOINT"
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Validate
        run: terraform validate
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan -no-color -out=tfplan 2>&1 | tee plan.txt
          echo "plan<<EOF" >> $GITHUB_OUTPUT
          head -c 60000 plan.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Comment Plan on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const plan = `${{ steps.plan.outputs.plan }}`;
            const output = `## Terraform Plan

            <details>
            <summary>Show Plan</summary>

            \`\`\`hcl
            ${plan}
            \`\`\`

            </details>

            *Triggered by: @${{ github.actor }}*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  apply:
    name: Apply
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || (github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=$TF_STATE_BUCKET" \
            -backend-config="region=$TF_STATE_REGION" \
            -backend-config="endpoint=$TF_STATE_ENDPOINT"
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Show Outputs
        run: terraform output
        working-directory: ${{ env.TF_WORKING_DIR }}

  destroy:
    name: Destroy
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=$TF_STATE_BUCKET" \
            -backend-config="region=$TF_STATE_REGION" \
            -backend-config="endpoint=$TF_STATE_ENDPOINT"
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Destroy
        run: terraform destroy -auto-approve
        working-directory: ${{ env.TF_WORKING_DIR }}
